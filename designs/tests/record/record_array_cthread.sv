//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.2
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: B_top ()
//
module B_top // "b_mod"
(
    input logic clk
);


//------------------------------------------------------------------------------
// Child module instances

A a_mod
(
  .clk(clk)
);

endmodule



//==============================================================================
//
// Module: A (test_array_cthread.cpp:810:5)
//
module A // "b_mod.a_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic [3:0] sig;
logic signed [31:0] t0;
logic signed [31:0] t1;
logic signed [31:0] t2;
logic signed [31:0] t3;
logic signed [31:0] t4;
logic signed [31:0] t5;
logic signed [31:0] t6;
logic signed [31:0] t7;
logic signed [31:0] t8;
logic signed [31:0] t9;
logic signed [31:0] t10;
logic signed [31:0] t11;
logic signed [31:0] t12;
logic signed [31:0] t13;
logic signed [31:0] t13a;
logic signed [31:0] t13b;
logic signed [31:0] t14;
logic signed [31:0] t14a;
logic signed [31:0] t14b;
logic signed [31:0] t14c;
logic signed [31:0] t15;
logic signed [31:0] t16;
logic signed [31:0] t17;
logic signed [31:0] t18;
logic signed [31:0] t19;
logic signed [31:0] t20;
logic signed [31:0] t21;
logic signed [31:0] t21a;

// Local parameters generated for C++ constants
localparam logic signed [31:0] ap_b = 11;

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr_declare (test_array_cthread.cpp:138:5) 

// Thread-local variables
logic [3:0] ad_b[2];
logic [3:0] ad_b_next[2];
logic signed [31:0] t0_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr_declare_comb     // test_array_cthread.cpp:138:5
    rec_loc_arr_declare_func;
end
function void rec_loc_arr_declare_func;
    logic signed [1:0] ad_a[2];
    logic [3:0] i;
    ad_b_next = ad_b;
    t0_next = t0;
    i = ad_b_next[0];
    t0_next = i;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr_declare_ff
    if ( ~nrst ) begin
    end
    else begin
        ad_b <= ad_b_next;
        t0 <= t0_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr0 (test_array_cthread.cpp:157:5) 

// Thread-local variables
logic signed [31:0] t1_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr0_comb     // test_array_cthread.cpp:157:5
    rec_loc_arr0_func;
end
function void rec_loc_arr0_func;
    logic signed [1:0] ap_a[2];
    logic [3:0] ap_b_1[2];
    integer i;
    t1_next = t1;
    ap_b_1[1] = 1;
    ap_b_1[0] = ap_b_1[1] + ap_b;
    i = ap_b_1[0];
    t1_next = i;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr0_ff
    if ( ~nrst ) begin
    end
    else begin
        t1 <= t1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr0a (test_array_cthread.cpp:177:5) 

// Thread-local variables
logic signed [31:0] ar_b;
logic signed [31:0] ar_b_next;
logic [3:0] ar_b0[2];
logic [3:0] ar_b_next0[2];
logic signed [31:0] t2_next;
logic rec_loc_arr0a_PROC_STATE;
logic rec_loc_arr0a_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr0a_comb     // test_array_cthread.cpp:177:5
    rec_loc_arr0a_func;
end
function void rec_loc_arr0a_func;
    logic signed [1:0] ar_a[2];
    ar_b_next = ar_b;
    ar_b_next0 = ar_b0;
    t2_next = t2;
    rec_loc_arr0a_PROC_STATE_next = rec_loc_arr0a_PROC_STATE;
    
    case (rec_loc_arr0a_PROC_STATE)
        0: begin
            ar_b_next0[1] = sig - 1;
            ar_b_next = sig + 1;
            rec_loc_arr0a_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:185:13;
        end
        1: begin
            ar_b_next0[0] = ar_b_next0[1] - ar_b_next;
            t2_next = ar_b_next0[0];
            ar_b_next0[1] = sig - 1;
            ar_b_next = sig + 1;
            rec_loc_arr0a_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:185:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr0a_ff
    if ( ~nrst ) begin
        rec_loc_arr0a_PROC_STATE <= 0;    // test_array_cthread.cpp:179:9;
    end
    else begin
        ar_b <= ar_b_next;
        ar_b0 <= ar_b_next0;
        t2 <= t2_next;
        rec_loc_arr0a_PROC_STATE <= rec_loc_arr0a_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr1 (test_array_cthread.cpp:194:5) 

// Thread-local variables
logic [3:0] br_b[2];
logic [3:0] br_b_next[2];
logic signed [31:0] t3_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr1_comb     // test_array_cthread.cpp:194:5
    rec_loc_arr1_func;
end
function void rec_loc_arr1_func;
    logic signed [1:0] br_a[2];
    integer i;
    br_b_next = br_b;
    t3_next = t3;
    i = sig;
    br_a[i] = 1;
    br_b_next[i + 1] = br_b_next[i] - 1;
    t3_next = br_b_next[i];
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr1_ff
    if ( ~nrst ) begin
    end
    else begin
        br_b <= br_b_next;
        t3 <= t3_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr2 (test_array_cthread.cpp:210:5) 

// Thread-local variables
logic [3:0] crr_b[2][3];
logic [3:0] crr_b_next[2][3];
logic signed [31:0] t4_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr2_comb     // test_array_cthread.cpp:210:5
    rec_loc_arr2_func;
end
function void rec_loc_arr2_func;
    logic signed [1:0] cr_a[2];
    logic [3:0] cr_b[2];
    logic signed [1:0] crr_a[2][3];
    integer c;
    crr_b_next = crr_b;
    t4_next = t4;
    cr_a[1] = 2;
    crr_a[1][2] = cr_a[1];
    cr_b[0] = 42;
    c = crr_b_next[1][0] + cr_b[0];
    t4_next = c;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr2_ff
    if ( ~nrst ) begin
    end
    else begin
        crr_b <= crr_b_next;
        t4 <= t4_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: code_scope_state_clean (test_array_cthread.cpp:228:5) 

// Thread-local variables
logic signed [31:0] k;
logic signed [31:0] k_next;
logic signed [31:0] t5_next;

// Next-state combinational logic
always_comb begin : code_scope_state_clean_comb     // test_array_cthread.cpp:228:5
    code_scope_state_clean_func;
end
function void code_scope_state_clean_func;
    logic signed [1:0] dd_a[2];
    logic [3:0] dd_b[2];
    integer j;
    k_next = k;
    t5_next = t5;
    dd_a[k_next] = 1;
    j = k_next;
    t5_next = j;
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : code_scope_state_clean_ff
    if ( ~nrst ) begin
        k <= sig;
    end
    else begin
        k <= k_next;
        t5 <= t5_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: code_scope_state_clean1 (test_array_cthread.cpp:245:5) 

// Thread-local variables
logic signed [31:0] k0;
logic signed [31:0] k_next0;
logic [1:0] code_scope_state_clean1_PROC_STATE;
logic [1:0] code_scope_state_clean1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : code_scope_state_clean1_comb     // test_array_cthread.cpp:245:5
    code_scope_state_clean1_func;
end
function void code_scope_state_clean1_func;
    logic signed [1:0] dd_a[2];
    logic [3:0] dd_b[2];
    k_next0 = k0;
    code_scope_state_clean1_PROC_STATE_next = code_scope_state_clean1_PROC_STATE;
    
    case (code_scope_state_clean1_PROC_STATE)
        0: begin
            dd_a[k_next0] = 1;
            code_scope_state_clean1_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:255:17;
        end
        1: begin
            k_next0++;
            dd_a[k_next0] = 2;
            code_scope_state_clean1_PROC_STATE_next = 0; return;    // test_array_cthread.cpp:262:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : code_scope_state_clean1_ff
    if ( ~nrst ) begin
        k0 <= sig;
        code_scope_state_clean1_PROC_STATE <= 0;    // test_array_cthread.cpp:248:9;
    end
    else begin
        k0 <= k_next0;
        code_scope_state_clean1_PROC_STATE <= code_scope_state_clean1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: code_scope_state_clean2 (test_array_cthread.cpp:267:5) 

// Thread-local variables
logic signed [31:0] k1;
logic signed [31:0] k_next1;
logic code_scope_state_clean2_PROC_STATE;
logic code_scope_state_clean2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : code_scope_state_clean2_comb     // test_array_cthread.cpp:267:5
    code_scope_state_clean2_func;
end
function void code_scope_state_clean2_func;
    logic signed [1:0] dd_a[2];
    logic [3:0] dd_b[2];
    k_next1 = k1;
    code_scope_state_clean2_PROC_STATE_next = code_scope_state_clean2_PROC_STATE;
    
    case (code_scope_state_clean2_PROC_STATE)
        0: begin
            dd_a[k_next1] = 1;
            code_scope_state_clean2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:277:17;
        end
        1: begin
            k_next1++;
            dd_a[k_next1] = 2;
            dd_a[k_next1] = 1;
            code_scope_state_clean2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:277:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : code_scope_state_clean2_ff
    if ( ~nrst ) begin
        k1 <= sig;
        code_scope_state_clean2_PROC_STATE <= 0;    // test_array_cthread.cpp:270:9;
    end
    else begin
        k1 <= k_next1;
        code_scope_state_clean2_PROC_STATE <= code_scope_state_clean2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr_multistate (test_array_cthread.cpp:287:5) 

// Thread-local variables
logic signed [31:0] k2;
logic signed [31:0] k_next2;
logic rec_loc_arr_multistate_PROC_STATE;
logic rec_loc_arr_multistate_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr_multistate_comb     // test_array_cthread.cpp:287:5
    rec_loc_arr_multistate_func;
end
function void rec_loc_arr_multistate_func;
    logic signed [1:0] dd_a[2];
    logic [3:0] dd_b[2];
    k_next2 = k2;
    rec_loc_arr_multistate_PROC_STATE_next = rec_loc_arr_multistate_PROC_STATE;
    
    case (rec_loc_arr_multistate_PROC_STATE)
        0: begin
            k_next2 = sig;
            dd_a[k_next2] = 2;
            rec_loc_arr_multistate_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:297:13;
        end
        1: begin
            dd_a[k_next2] = 3;
            k_next2 = sig;
            dd_a[k_next2] = 2;
            rec_loc_arr_multistate_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:297:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr_multistate_ff
    if ( ~nrst ) begin
        rec_loc_arr_multistate_PROC_STATE <= 0;    // test_array_cthread.cpp:290:9;
    end
    else begin
        k2 <= k_next2;
        rec_loc_arr_multistate_PROC_STATE <= rec_loc_arr_multistate_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr3 (test_array_cthread.cpp:304:5) 

// Thread-local variables
logic signed [1:0] dr_a[2];
logic signed [1:0] dr_a_next[2];
logic signed [31:0] i0;
logic signed [31:0] i_next;
logic [3:0] drr_b[2][3];
logic [3:0] drr_b_next[2][3];
logic rec_loc_arr3_PROC_STATE;
logic rec_loc_arr3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr3_comb     // test_array_cthread.cpp:304:5
    rec_loc_arr3_func;
end
function void rec_loc_arr3_func;
    logic [3:0] dr_b[2];
    logic signed [1:0] drr_a[2][3];
    dr_a_next = dr_a;
    drr_b_next = drr_b;
    i_next = i0;
    rec_loc_arr3_PROC_STATE_next = rec_loc_arr3_PROC_STATE;
    
    case (rec_loc_arr3_PROC_STATE)
        0: begin
            i_next = sig;
            dr_a_next[i_next] = 2;
            drr_a[1][i_next + 1] = dr_a_next[1];
            rec_loc_arr3_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:314:13;
        end
        1: begin
            i_next = drr_b_next[1][i_next];
            i_next = sig;
            dr_a_next[i_next] = 2;
            drr_a[1][i_next + 1] = dr_a_next[1];
            rec_loc_arr3_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:314:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr3_ff
    if ( ~nrst ) begin
        rec_loc_arr3_PROC_STATE <= 0;    // test_array_cthread.cpp:306:9;
    end
    else begin
        dr_a <= dr_a_next;
        i0 <= i_next;
        drr_b <= drr_b_next;
        rec_loc_arr3_PROC_STATE <= rec_loc_arr3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr4 (test_array_cthread.cpp:322:5) 

// Thread-local variables
logic [3:0] err_b[2][3][4];
logic [3:0] err_b_next[2][3][4];
logic signed [31:0] i1;
logic signed [31:0] i_next0;
logic signed [31:0] j0;
logic signed [31:0] j_next;
logic signed [31:0] t6_next;
logic rec_loc_arr4_PROC_STATE;
logic rec_loc_arr4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr4_comb     // test_array_cthread.cpp:322:5
    rec_loc_arr4_func;
end
function void rec_loc_arr4_func;
    logic signed [1:0] err_a[2][3][4];
    err_b_next = err_b;
    i_next0 = i1;
    j_next = j0;
    t6_next = t6;
    rec_loc_arr4_PROC_STATE_next = rec_loc_arr4_PROC_STATE;
    
    case (rec_loc_arr4_PROC_STATE)
        0: begin
            i_next0 = sig;
            j_next = sig;
            err_a[1][2][3] = j_next;
            err_b_next[1][j_next][1] = 42;
            err_b_next[i_next0][j_next + 1][2] = err_b_next[1][j_next][i_next0];
            rec_loc_arr4_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:333:13;
        end
        1: begin
            i_next0 = err_b_next[i_next0][j_next + 1][2] + err_b_next[0][1][j_next];
            t6_next = i_next0;
            i_next0 = sig;
            j_next = sig;
            err_a[1][2][3] = j_next;
            err_b_next[1][j_next][1] = 42;
            err_b_next[i_next0][j_next + 1][2] = err_b_next[1][j_next][i_next0];
            rec_loc_arr4_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:333:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr4_ff
    if ( ~nrst ) begin
        rec_loc_arr4_PROC_STATE <= 0;    // test_array_cthread.cpp:324:9;
    end
    else begin
        err_b <= err_b_next;
        i1 <= i_next0;
        j0 <= j_next;
        t6 <= t6_next;
        rec_loc_arr4_PROC_STATE <= rec_loc_arr4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr5 (test_array_cthread.cpp:343:5) 

// Thread-local variables
logic signed [31:0] i2;
logic signed [31:0] i_next1;
logic [3:0] frr_b[2][3];
logic [3:0] frr_b_next[2][3];
logic signed [31:0] t7_next;
logic rec_loc_arr5_PROC_STATE;
logic rec_loc_arr5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr5_comb     // test_array_cthread.cpp:343:5
    rec_loc_arr5_func;
end
function void rec_loc_arr5_func;
    logic signed [1:0] frr_a[2][3];
    integer j;
    frr_b_next = frr_b;
    i_next1 = i2;
    t7_next = t7;
    rec_loc_arr5_PROC_STATE_next = rec_loc_arr5_PROC_STATE;
    
    case (rec_loc_arr5_PROC_STATE)
        0: begin
            i_next1 = sig;
            rec_loc_arr5_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:350:13;
        end
        1: begin
            frr_b_next[i_next1][1] = 42;
            j = frr_b_next[1][1];
            t7_next = j;
            i_next1 = sig;
            rec_loc_arr5_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:350:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr5_ff
    if ( ~nrst ) begin
        rec_loc_arr5_PROC_STATE <= 0;    // test_array_cthread.cpp:345:9;
    end
    else begin
        i2 <= i_next1;
        frr_b <= frr_b_next;
        t7 <= t7_next;
        rec_loc_arr5_PROC_STATE <= rec_loc_arr5_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr6 (test_array_cthread.cpp:359:5) 

// Thread-local variables
logic signed [31:0] i3;
logic signed [31:0] i_next2;
logic [3:0] grr_b[2][3];
logic [3:0] grr_b_next[2][3];
logic signed [31:0] t8_next;
logic rec_loc_arr6_PROC_STATE;
logic rec_loc_arr6_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr6_comb     // test_array_cthread.cpp:359:5
    rec_loc_arr6_func;
end
function void rec_loc_arr6_func;
    logic signed [1:0] grr_a[2][3];
    integer j;
    grr_b_next = grr_b;
    i_next2 = i3;
    t8_next = t8;
    rec_loc_arr6_PROC_STATE_next = rec_loc_arr6_PROC_STATE;
    
    case (rec_loc_arr6_PROC_STATE)
        0: begin
            i_next2 = sig;
            rec_loc_arr6_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:366:13;
        end
        1: begin
            grr_b_next[1][i_next2] = 42;
            j = grr_b_next[1][1];
            t8_next = i_next2 + j;
            i_next2 = sig;
            rec_loc_arr6_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:366:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr6_ff
    if ( ~nrst ) begin
        rec_loc_arr6_PROC_STATE <= 0;    // test_array_cthread.cpp:361:9;
    end
    else begin
        i3 <= i_next2;
        grr_b <= grr_b_next;
        t8 <= t8_next;
        rec_loc_arr6_PROC_STATE <= rec_loc_arr6_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr7 (test_array_cthread.cpp:375:5) 

// Thread-local variables
logic signed [31:0] i4;
logic signed [31:0] i_next3;
logic [3:0] hrr_b[2][3];
logic [3:0] hrr_b_next[2][3];
logic signed [31:0] t9_next;
logic rec_loc_arr7_PROC_STATE;
logic rec_loc_arr7_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr7_comb     // test_array_cthread.cpp:375:5
    rec_loc_arr7_func;
end
function void rec_loc_arr7_func;
    logic signed [1:0] hrr_a[2][3];
    integer j;
    hrr_b_next = hrr_b;
    i_next3 = i4;
    t9_next = t9;
    rec_loc_arr7_PROC_STATE_next = rec_loc_arr7_PROC_STATE;
    
    case (rec_loc_arr7_PROC_STATE)
        0: begin
            i_next3 = sig;
            rec_loc_arr7_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:382:13;
        end
        1: begin
            hrr_b_next[1][1] = 42;
            j = hrr_b_next[i_next3][1];
            t9_next = i_next3 + j;
            i_next3 = sig;
            rec_loc_arr7_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:382:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr7_ff
    if ( ~nrst ) begin
        rec_loc_arr7_PROC_STATE <= 0;    // test_array_cthread.cpp:377:9;
    end
    else begin
        i4 <= i_next3;
        hrr_b <= hrr_b_next;
        t9 <= t9_next;
        rec_loc_arr7_PROC_STATE <= rec_loc_arr7_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr8 (test_array_cthread.cpp:391:5) 

// Thread-local variables
logic signed [31:0] i5;
logic signed [31:0] i_next4;
logic [3:0] jrr_b[2][3];
logic [3:0] jrr_b_next[2][3];
logic signed [31:0] t10_next;
logic rec_loc_arr8_PROC_STATE;
logic rec_loc_arr8_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr8_comb     // test_array_cthread.cpp:391:5
    rec_loc_arr8_func;
end
function void rec_loc_arr8_func;
    logic signed [1:0] jrr_a[2][3];
    integer j;
    i_next4 = i5;
    jrr_b_next = jrr_b;
    t10_next = t10;
    rec_loc_arr8_PROC_STATE_next = rec_loc_arr8_PROC_STATE;
    
    case (rec_loc_arr8_PROC_STATE)
        0: begin
            i_next4 = sig;
            rec_loc_arr8_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:398:13;
        end
        1: begin
            jrr_b_next[1][1] = 42;
            j = jrr_b_next[1][i_next4];
            t10_next = i_next4 + j;
            i_next4 = sig;
            rec_loc_arr8_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:398:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr8_ff
    if ( ~nrst ) begin
        rec_loc_arr8_PROC_STATE <= 0;    // test_array_cthread.cpp:393:9;
    end
    else begin
        i5 <= i_next4;
        jrr_b <= jrr_b_next;
        t10 <= t10_next;
        rec_loc_arr8_PROC_STATE <= rec_loc_arr8_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr9 (test_array_cthread.cpp:407:5) 

// Thread-local variables
logic signed [31:0] i6;
logic signed [31:0] i_next5;
logic [3:0] irr_b[2][3];
logic [3:0] irr_b_next[2][3];
logic signed [31:0] t11_next;
logic rec_loc_arr9_PROC_STATE;
logic rec_loc_arr9_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr9_comb     // test_array_cthread.cpp:407:5
    rec_loc_arr9_func;
end
function void rec_loc_arr9_func;
    logic signed [1:0] irr_a[2][3];
    integer j;
    i_next5 = i6;
    irr_b_next = irr_b;
    t11_next = t11;
    rec_loc_arr9_PROC_STATE_next = rec_loc_arr9_PROC_STATE;
    
    case (rec_loc_arr9_PROC_STATE)
        0: begin
            i_next5 = sig;
            rec_loc_arr9_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:414:13;
        end
        1: begin
            irr_b_next[i_next5][i_next5] = 42;
            j = irr_b_next[i_next5][i_next5];
            t11_next = i_next5 + j;
            i_next5 = sig;
            rec_loc_arr9_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:414:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr9_ff
    if ( ~nrst ) begin
        rec_loc_arr9_PROC_STATE <= 0;    // test_array_cthread.cpp:409:9;
    end
    else begin
        i6 <= i_next5;
        irr_b <= irr_b_next;
        t11 <= t11_next;
        rec_loc_arr9_PROC_STATE <= rec_loc_arr9_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_loc_arr10 (test_array_cthread.cpp:423:5) 

// Thread-local variables
logic signed [31:0] i7;
logic signed [31:0] i_next6;
logic signed [31:0] t12_next;
logic rec_loc_arr10_PROC_STATE;
logic rec_loc_arr10_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_loc_arr10_comb     // test_array_cthread.cpp:423:5
    rec_loc_arr10_func;
end
function void rec_loc_arr10_func;
    logic signed [1:0] krr_a[2][3];
    logic [3:0] krr_b[2][3];
    integer j;
    i_next6 = i7;
    t12_next = t12;
    rec_loc_arr10_PROC_STATE_next = rec_loc_arr10_PROC_STATE;
    
    case (rec_loc_arr10_PROC_STATE)
        0: begin
            i_next6 = sig;
            rec_loc_arr10_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:430:13;
        end
        1: begin
            krr_b[1][2] = 42;
            j = krr_b[1][2];
            t12_next = i_next6 + j;
            i_next6 = sig;
            rec_loc_arr10_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:430:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_loc_arr10_ff
    if ( ~nrst ) begin
        rec_loc_arr10_PROC_STATE <= 0;    // test_array_cthread.cpp:425:9;
    end
    else begin
        i7 <= i_next6;
        t12 <= t12_next;
        rec_loc_arr10_PROC_STATE <= rec_loc_arr10_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_field_assign (test_array_cthread.cpp:457:5) 

// Thread-local variables
logic [3:0] pr_b[3];
logic [3:0] pr_b_next[3];
logic signed [1:0] rr_a[3];
logic signed [1:0] rr_a_next[3];

// Next-state combinational logic
always_comb begin : rec_arr_elem_field_assign_comb     // test_array_cthread.cpp:457:5
    rec_arr_elem_field_assign_func;
end
function void rec_arr_elem_field_assign_func;
    logic signed [1:0] pr_a[3];
    logic [3:0] rr_b[3];
    pr_b_next = pr_b;
    rr_a_next = rr_a;
    for (integer i = 0; i < 2; i++)
    begin
        rr_b[i] = pr_b_next[i + 1];
        pr_a[i + 1] = rr_a_next[i];
    end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_field_assign_ff
    if ( ~nrst ) begin
    end
    else begin
        pr_b <= pr_b_next;
        rr_a <= rr_a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_const_val1 (test_array_cthread.cpp:561:5) 

// Thread-local variables
logic signed [1:0] par_a;
logic signed [1:0] par_a_next;
logic [3:0] par_b;
logic [3:0] par_b_next;
logic signed [31:0] t14_next;
logic [1:0] rec_arr_elem_const_val1_PROC_STATE;
logic [1:0] rec_arr_elem_const_val1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_const_val1_comb     // test_array_cthread.cpp:561:5
    rec_arr_elem_const_val1_func;
end
function void rec_arr_elem_const_val1_func;
    logic signed [1:0] sr_a;
    logic [3:0] sr_b;
    integer i;
    par_a_next = par_a;
    par_b_next = par_b;
    t14_next = t14;
    rec_arr_elem_const_val1_PROC_STATE_next = rec_arr_elem_const_val1_PROC_STATE;
    
    case (rec_arr_elem_const_val1_PROC_STATE)
        0: begin
            sr_a = 0;
            sr_b = 0;
            sr_b = sig;
            par_a_next = sr_a; par_b_next = sr_b;
            // Call ff1() begin
            rec_arr_elem_const_val1_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:535:9;
            // Call ff1() end
        end
        1: begin
            // Call ff1() begin
            i = par_a_next + par_b_next;
            t14_next = i;
            // Call ff1() end
            rec_arr_elem_const_val1_PROC_STATE_next = 0; return;    // test_array_cthread.cpp:569:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_const_val1_ff
    if ( ~nrst ) begin
        rec_arr_elem_const_val1_PROC_STATE <= 0;    // test_array_cthread.cpp:563:9;
    end
    else begin
        par_a <= par_a_next;
        par_b <= par_b_next;
        t14 <= t14_next;
        rec_arr_elem_const_val1_PROC_STATE <= rec_arr_elem_const_val1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_const_val2 (test_array_cthread.cpp:573:5) 

// Thread-local variables
logic signed [1:0] par_a0;
logic signed [1:0] par_a_next0;
logic [3:0] par_b0;
logic [3:0] par_b_next0;
logic signed [31:0] t14a_next;
logic signed [1:0] sr_a0;
logic signed [1:0] sr_a_next;
logic [3:0] sr_b0;
logic [3:0] sr_b_next;
logic [1:0] rec_arr_elem_const_val2_PROC_STATE;
logic [1:0] rec_arr_elem_const_val2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_const_val2_comb     // test_array_cthread.cpp:573:5
    rec_arr_elem_const_val2_func;
end
function void rec_arr_elem_const_val2_func;
    integer i;
    par_a_next0 = par_a0;
    par_b_next0 = par_b0;
    sr_a_next = sr_a0;
    sr_b_next = sr_b0;
    t14a_next = t14a;
    rec_arr_elem_const_val2_PROC_STATE_next = rec_arr_elem_const_val2_PROC_STATE;
    
    case (rec_arr_elem_const_val2_PROC_STATE)
        0: begin
            sr_a_next = 0;
            sr_b_next = 0;
            rec_arr_elem_const_val2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:578:13;
        end
        1: begin
            par_a_next0 = sr_a_next; par_b_next0 = sr_b_next;
            // Call ff1a() begin
            rec_arr_elem_const_val2_PROC_STATE_next = 2; return;    // test_array_cthread.cpp:542:9;
            // Call ff1a() end
        end
        2: begin
            // Call ff1a() begin
            i = par_a_next0 + par_b_next0;
            t14a_next = i;
            // Call ff1a() end
            sr_a_next = 0;
            sr_b_next = 0;
            rec_arr_elem_const_val2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:578:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_const_val2_ff
    if ( ~nrst ) begin
        rec_arr_elem_const_val2_PROC_STATE <= 0;    // test_array_cthread.cpp:575:9;
    end
    else begin
        par_a0 <= par_a_next0;
        par_b0 <= par_b_next0;
        t14a <= t14a_next;
        sr_a0 <= sr_a_next;
        sr_b0 <= sr_b_next;
        rec_arr_elem_const_val2_PROC_STATE <= rec_arr_elem_const_val2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_const_val3 (test_array_cthread.cpp:584:5) 

// Thread-local variables
logic signed [1:0] crra_a[3];
logic signed [1:0] crra_a_next[3];
logic [3:0] crra_b[3];
logic [3:0] crra_b_next[3];
logic signed [1:0] par_a1;
logic signed [1:0] par_a_next1;
logic [3:0] par_b1;
logic [3:0] par_b_next1;
logic signed [31:0] t14b_next;
logic [1:0] rec_arr_elem_const_val3_PROC_STATE;
logic [1:0] rec_arr_elem_const_val3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_const_val3_comb     // test_array_cthread.cpp:584:5
    rec_arr_elem_const_val3_func;
end
function void rec_arr_elem_const_val3_func;
    integer i;
    crra_a_next = crra_a;
    crra_b_next = crra_b;
    par_a_next1 = par_a1;
    par_b_next1 = par_b1;
    t14b_next = t14b;
    rec_arr_elem_const_val3_PROC_STATE_next = rec_arr_elem_const_val3_PROC_STATE;
    
    case (rec_arr_elem_const_val3_PROC_STATE)
        0: begin
            par_a_next1 = crra_a_next[1]; par_b_next1 = crra_b_next[1];
            // Call ff1b() begin
            rec_arr_elem_const_val3_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:549:9;
            // Call ff1b() end
        end
        1: begin
            // Call ff1b() begin
            i = par_a_next1 + par_b_next1;
            t14b_next = i;
            // Call ff1b() end
            rec_arr_elem_const_val3_PROC_STATE_next = 0; return;    // test_array_cthread.cpp:590:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_const_val3_ff
    if ( ~nrst ) begin
        rec_arr_elem_const_val3_PROC_STATE <= 0;    // test_array_cthread.cpp:587:9;
    end
    else begin
        crra_a <= crra_a_next;
        crra_b <= crra_b_next;
        par_a1 <= par_a_next1;
        par_b1 <= par_b_next1;
        t14b <= t14b_next;
        rec_arr_elem_const_val3_PROC_STATE <= rec_arr_elem_const_val3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_const_val4 (test_array_cthread.cpp:594:5) 

// Thread-local variables
logic signed [1:0] par_a2;
logic signed [1:0] par_a_next2;
logic [3:0] par_b2;
logic [3:0] par_b_next2;
logic signed [31:0] t14c_next;
logic signed [1:0] crrb_a[3];
logic signed [1:0] crrb_a_next[3];
logic [3:0] crrb_b[3];
logic [3:0] crrb_b_next[3];
logic [1:0] rec_arr_elem_const_val4_PROC_STATE;
logic [1:0] rec_arr_elem_const_val4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_const_val4_comb     // test_array_cthread.cpp:594:5
    rec_arr_elem_const_val4_func;
end
function void rec_arr_elem_const_val4_func;
    integer i;
    integer i_1;
    crrb_a_next = crrb_a;
    crrb_b_next = crrb_b;
    par_a_next2 = par_a2;
    par_b_next2 = par_b2;
    t14c_next = t14c;
    rec_arr_elem_const_val4_PROC_STATE_next = rec_arr_elem_const_val4_PROC_STATE;
    
    case (rec_arr_elem_const_val4_PROC_STATE)
        0: begin
            rec_arr_elem_const_val4_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:599:13;
        end
        1: begin
            i = sig;
            par_a_next2 = crrb_a_next[i]; par_b_next2 = crrb_b_next[i];
            // Call ff1c() begin
            rec_arr_elem_const_val4_PROC_STATE_next = 2; return;    // test_array_cthread.cpp:556:9;
            // Call ff1c() end
        end
        2: begin
            // Call ff1c() begin
            i_1 = par_a_next2 + par_b_next2;
            t14c_next = i_1;
            // Call ff1c() end
            rec_arr_elem_const_val4_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:599:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_const_val4_ff
    if ( ~nrst ) begin
        rec_arr_elem_const_val4_PROC_STATE <= 0;    // test_array_cthread.cpp:597:9;
    end
    else begin
        par_a2 <= par_a_next2;
        par_b2 <= par_b_next2;
        t14c <= t14c_next;
        crrb_a <= crrb_a_next;
        crrb_b <= crrb_b_next;
        rec_arr_elem_const_val4_PROC_STATE <= rec_arr_elem_const_val4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_val (test_array_cthread.cpp:493:5) 

// Thread-local variables
logic signed [31:0] t13_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_val_comb     // test_array_cthread.cpp:493:5
    rec_arr_elem_func_param_val_func;
end
function void rec_arr_elem_func_param_val_func;
    logic signed [1:0] sr_a;
    logic [3:0] sr_b;
    logic signed [1:0] par_a_1;
    logic [3:0] par_b_1;
    integer i;
    t13_next = t13;
    sr_a = 0;
    sr_b = 0;
    par_a_1 = sr_a; par_b_1 = sr_b;
    // Call f1() begin
    i = par_b_1;
    t13_next = i;
    // Call f1() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_val_ff
    if ( ~nrst ) begin
    end
    else begin
        t13 <= t13_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_val2 (test_array_cthread.cpp:505:5) 

// Thread-local variables
logic signed [1:0] tr_a[3];
logic signed [1:0] tr_a_next[3];
logic [3:0] tr_b[3];
logic [3:0] tr_b_next[3];
logic signed [31:0] t13a_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_val2_comb     // test_array_cthread.cpp:505:5
    rec_arr_elem_func_param_val2_func;
end
function void rec_arr_elem_func_param_val2_func;
    logic signed [1:0] par_a_1;
    logic [3:0] par_b_1;
    integer i;
    t13a_next = t13a;
    tr_a_next = tr_a;
    tr_b_next = tr_b;
    par_a_1 = tr_a_next[1]; par_b_1 = tr_b_next[1];
    // Call f1a() begin
    i = par_b_1;
    t13a_next = i;
    // Call f1a() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_val2_ff
    if ( ~nrst ) begin
    end
    else begin
        tr_a <= tr_a_next;
        tr_b <= tr_b_next;
        t13a <= t13a_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_val3 (test_array_cthread.cpp:518:5) 

// Thread-local variables
logic signed [31:0] i8;
logic signed [31:0] i_next7;
logic signed [1:0] tr_a0[3];
logic signed [1:0] tr_a_next0[3];
logic [3:0] tr_b0[3];
logic [3:0] tr_b_next0[3];
logic signed [31:0] t13b_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_val3_comb     // test_array_cthread.cpp:518:5
    rec_arr_elem_func_param_val3_func;
end
function void rec_arr_elem_func_param_val3_func;
    logic signed [1:0] par_a_1;
    logic [3:0] par_b_1;
    integer i;
    i_next7 = i8;
    t13b_next = t13b;
    tr_a_next0 = tr_a0;
    tr_b_next0 = tr_b0;
    par_a_1 = tr_a_next0[i_next7]; par_b_1 = tr_b_next0[i_next7];
    // Call f1b() begin
    i = par_b_1;
    t13b_next = i;
    // Call f1b() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_val3_ff
    if ( ~nrst ) begin
        i8 <= sig;
    end
    else begin
        i8 <= i_next7;
        tr_a0 <= tr_a_next0;
        tr_b0 <= tr_b_next0;
        t13b <= t13b_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_ref (test_array_cthread.cpp:613:5) 

// Thread-local variables
logic [3:0] vr_b[3];
logic [3:0] vr_b_next[3];
logic signed [31:0] t15_next;
logic rec_arr_elem_func_param_ref_PROC_STATE;
logic rec_arr_elem_func_param_ref_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_ref_comb     // test_array_cthread.cpp:613:5
    rec_arr_elem_func_param_ref_func;
end
function void rec_arr_elem_func_param_ref_func;
    logic signed [1:0] vr_a[3];
    integer k_1;
    integer i;
    t15_next = t15;
    vr_b_next = vr_b;
    rec_arr_elem_func_param_ref_PROC_STATE_next = rec_arr_elem_func_param_ref_PROC_STATE;
    
    case (rec_arr_elem_func_param_ref_PROC_STATE)
        0: begin
            // Call f2() begin
            k_1 = vr_b_next[1];
            t15_next = k_1;
            // Call f2() end
            rec_arr_elem_func_param_ref_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:619:13;
        end
        1: begin
            i = sig;
            // Call f2() begin
            k_1 = vr_b_next[i];
            t15_next = k_1;
            // Call f2() end
            // Call f2() begin
            k_1 = vr_b_next[1];
            t15_next = k_1;
            // Call f2() end
            rec_arr_elem_func_param_ref_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:619:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_ref_ff
    if ( ~nrst ) begin
        rec_arr_elem_func_param_ref_PROC_STATE <= 0;    // test_array_cthread.cpp:615:9;
    end
    else begin
        vr_b <= vr_b_next;
        t15 <= t15_next;
        rec_arr_elem_func_param_ref_PROC_STATE <= rec_arr_elem_func_param_ref_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_ref2 (test_array_cthread.cpp:657:5) 

// Thread-local variables
logic signed [31:0] i9;
logic signed [31:0] i_next8;
logic [3:0] wrr_b[2];
logic [3:0] wrr_b_next[2];
logic [3:0] wr_b[3];
logic [3:0] wr_b_next[3];
logic signed [31:0] t16_next;
logic rec_arr_elem_func_param_ref2_PROC_STATE;
logic rec_arr_elem_func_param_ref2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_ref2_comb     // test_array_cthread.cpp:657:5
    rec_arr_elem_func_param_ref2_func;
end
function void rec_arr_elem_func_param_ref2_func;
    logic signed [1:0] wrr_a[2];
    logic signed [1:0] wr_a[3];
    integer k_1;
    logic signed [1:0] w_a;
    logic [3:0] w_b;
    i_next8 = i9;
    t16_next = t16;
    wr_b_next = wr_b;
    wrr_b_next = wrr_b;
    rec_arr_elem_func_param_ref2_PROC_STATE_next = rec_arr_elem_func_param_ref2_PROC_STATE;
    
    case (rec_arr_elem_func_param_ref2_PROC_STATE)
        0: begin
            // Call f2_two() begin
            k_1 = wr_b_next[1] + wrr_b_next[i_next8];
            t16_next = k_1;
            // Call f2_two() end
            // Call f2_two() begin
            k_1 = wr_b_next[i_next8] + wr_b_next[1];
            t16_next = k_1;
            // Call f2_two() end
            rec_arr_elem_func_param_ref2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:668:13;
        end
        1: begin
            w_a = 0;
            w_b = 0;
            // Call f2_two() begin
            k_1 = w_b + wrr_b_next[0];
            t16_next = k_1;
            // Call f2_two() end
            // Call f2_two() begin
            k_1 = wr_b_next[i_next8 - 1] + w_b;
            t16_next = k_1;
            // Call f2_two() end
            // Call f2_two() begin
            k_1 = wr_b_next[1] + wrr_b_next[i_next8];
            t16_next = k_1;
            // Call f2_two() end
            // Call f2_two() begin
            k_1 = wr_b_next[i_next8] + wr_b_next[1];
            t16_next = k_1;
            // Call f2_two() end
            rec_arr_elem_func_param_ref2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:668:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_ref2_ff
    if ( ~nrst ) begin
        logic signed [1:0] wrr_a[2];
        i9 <= sig;
        rec_arr_elem_func_param_ref2_PROC_STATE <= 0;    // test_array_cthread.cpp:661:9;
    end
    else begin
        i9 <= i_next8;
        wrr_b <= wrr_b_next;
        wr_b <= wr_b_next;
        t16 <= t16_next;
        rec_arr_elem_func_param_ref2_PROC_STATE <= rec_arr_elem_func_param_ref2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_ref3 (test_array_cthread.cpp:680:5) 

// Thread-local variables
logic signed [31:0] i10;
logic signed [31:0] i_next9;
logic signed [1:0] vr_a0[3];
logic signed [1:0] vr_a_next[3];
logic signed [31:0] t17_next;
logic rec_arr_elem_func_param_ref3_PROC_STATE;
logic rec_arr_elem_func_param_ref3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_ref3_comb     // test_array_cthread.cpp:680:5
    rec_arr_elem_func_param_ref3_func;
end
function void rec_arr_elem_func_param_ref3_func;
    logic [3:0] vr_b_1[3];
    i_next9 = i10;
    t17_next = t17;
    vr_a_next = vr_a0;
    rec_arr_elem_func_param_ref3_PROC_STATE_next = rec_arr_elem_func_param_ref3_PROC_STATE;
    
    case (rec_arr_elem_func_param_ref3_PROC_STATE)
        0: begin
            // Call f3() begin
            vr_b_1[1] = 1;
            // Call f3() end
            // Call f3() begin
            vr_b_1[1] = 1;
            // Call f3() end
            // Call f3() begin
            vr_b_1[i_next9 + 1] = 1;
            // Call f3() end
            rec_arr_elem_func_param_ref3_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:690:13;
        end
        1: begin
            // Call f3() begin
            vr_b_1[i_next9 - 1] = 1;
            // Call f3() end
            t17_next = vr_a_next[i_next9];
            // Call f3() begin
            vr_b_1[1] = 1;
            // Call f3() end
            // Call f3() begin
            vr_b_1[1] = 1;
            // Call f3() end
            // Call f3() begin
            vr_b_1[i_next9 + 1] = 1;
            // Call f3() end
            rec_arr_elem_func_param_ref3_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:690:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_ref3_ff
    if ( ~nrst ) begin
        i10 <= sig;
        rec_arr_elem_func_param_ref3_PROC_STATE <= 0;    // test_array_cthread.cpp:683:9;
    end
    else begin
        i10 <= i_next9;
        vr_a0 <= vr_a_next;
        t17 <= t17_next;
        rec_arr_elem_func_param_ref3_PROC_STATE <= rec_arr_elem_func_param_ref3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_func_param_val (test_array_cthread.cpp:781:5) 

// Thread-local variables
logic [3:0] ar_b1[2];
logic [3:0] ar_b_next1[2];
logic signed [1:0] ar_a0[2];
logic signed [1:0] ar_a_next[2];
logic signed [31:0] t21_next;

// Next-state combinational logic
always_comb begin : rec_arr_func_param_val_comb     // test_array_cthread.cpp:781:5
    rec_arr_func_param_val_func;
end
function void rec_arr_func_param_val_func;
    integer indx;
    logic c;
    ar_a_next = ar_a0;
    ar_b_next1 = ar_b1;
    t21_next = t21;
    // Call f5() begin
    indx = ar_b_next1[1];
    c = ar_a_next[indx] == 2;
    t21_next = c;
    // Call f5() end
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_func_param_val_ff
    if ( ~nrst ) begin
    end
    else begin
        ar_b1 <= ar_b_next1;
        ar_a0 <= ar_a_next;
        t21 <= t21_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_func_param_val2 (test_array_cthread.cpp:791:5) 

// Thread-local variables
logic [3:0] ar_b2[2];
logic [3:0] ar_b_next2[2];
logic signed [1:0] ar_a1[2];
logic signed [1:0] ar_a_next0[2];
logic signed [31:0] t21a_next;
logic rec_arr_func_param_val2_PROC_STATE;
logic rec_arr_func_param_val2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_func_param_val2_comb     // test_array_cthread.cpp:791:5
    rec_arr_func_param_val2_func;
end
function void rec_arr_func_param_val2_func;
    integer i;
    integer indx;
    logic c;
    ar_a_next0 = ar_a1;
    ar_b_next2 = ar_b2;
    t21a_next = t21a;
    rec_arr_func_param_val2_PROC_STATE_next = rec_arr_func_param_val2_PROC_STATE;
    
    case (rec_arr_func_param_val2_PROC_STATE)
        0: begin
            i = sig;
            ar_a_next0[i] = 0;
            ar_b_next2[i] = 1;
            rec_arr_func_param_val2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:799:13;
        end
        1: begin
            // Call f5a() begin
            indx = ar_b_next2[1];
            c = ar_a_next0[indx] == 2;
            t21a_next = c;
            // Call f5a() end
            i = sig;
            ar_a_next0[i] = 0;
            ar_b_next2[i] = 1;
            rec_arr_func_param_val2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:799:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_func_param_val2_ff
    if ( ~nrst ) begin
        rec_arr_func_param_val2_PROC_STATE <= 0;    // test_array_cthread.cpp:793:9;
    end
    else begin
        ar_b2 <= ar_b_next2;
        ar_a1 <= ar_a_next0;
        t21a <= t21a_next;
        rec_arr_func_param_val2_PROC_STATE <= rec_arr_func_param_val2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_cref1 (test_array_cthread.cpp:706:5) 

// Thread-local variables
logic signed [1:0] cvr_a[3];
logic signed [1:0] cvr_a_next[3];
logic [3:0] cvr_b[3];
logic [3:0] cvr_b_next[3];
logic signed [31:0] t18_next;
logic signed [1:0] cwr_a[3];
logic signed [1:0] cwr_a_next[3];
logic [3:0] cwr_b[3];
logic [3:0] cwr_b_next[3];
logic [1:0] rec_arr_elem_func_param_cref1_PROC_STATE;
logic [1:0] rec_arr_elem_func_param_cref1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_cref1_comb     // test_array_cthread.cpp:706:5
    rec_arr_elem_func_param_cref1_func;
end
function void rec_arr_elem_func_param_cref1_func;
    integer indx;
    integer res;
    cvr_a_next = cvr_a;
    cvr_b_next = cvr_b;
    cwr_a_next = cwr_a;
    cwr_b_next = cwr_b;
    t18_next = t18;
    rec_arr_elem_func_param_cref1_PROC_STATE_next = rec_arr_elem_func_param_cref1_PROC_STATE;
    
    case (rec_arr_elem_func_param_cref1_PROC_STATE)
        0: begin
            // Call cref_sum() begin
            res = cvr_a_next[1] + cvr_b_next[1];
            t18_next = res;
            // Call cref_sum() end
            rec_arr_elem_func_param_cref1_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:714:13;
        end
        1: begin
            indx = sig;
            // Call cref_sum() begin
            res = cwr_a_next[indx] + cwr_b_next[indx];
            t18_next = res;
            // Call cref_sum() end
            rec_arr_elem_func_param_cref1_PROC_STATE_next = 0; return;    // test_array_cthread.cpp:719:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_cref1_ff
    if ( ~nrst ) begin
        integer indx;
        indx = 0;
        rec_arr_elem_func_param_cref1_PROC_STATE <= 0;    // test_array_cthread.cpp:709:9;
    end
    else begin
        cvr_a <= cvr_a_next;
        cvr_b <= cvr_b_next;
        t18 <= t18_next;
        cwr_a <= cwr_a_next;
        cwr_b <= cwr_b_next;
        rec_arr_elem_func_param_cref1_PROC_STATE <= rec_arr_elem_func_param_cref1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_cref2 (test_array_cthread.cpp:732:5) 

// Thread-local variables
logic signed [1:0] cvrr_a[3];
logic signed [1:0] cvrr_a_next[3];
logic signed [31:0] res0;
logic signed [31:0] res_next;
logic [3:0] cvrr_b[3];
logic [3:0] cvrr_b_next[3];
logic signed [31:0] t19_next;
logic [1:0] rec_arr_elem_func_param_cref2_PROC_STATE;
logic [1:0] rec_arr_elem_func_param_cref2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_cref2_comb     // test_array_cthread.cpp:732:5
    rec_arr_elem_func_param_cref2_func;
end
function void rec_arr_elem_func_param_cref2_func;
    integer TMP_0;
    integer res;
    cvrr_a_next = cvrr_a;
    cvrr_b_next = cvrr_b;
    res_next = res0;
    t19_next = t19;
    rec_arr_elem_func_param_cref2_PROC_STATE_next = rec_arr_elem_func_param_cref2_PROC_STATE;
    
    case (rec_arr_elem_func_param_cref2_PROC_STATE)
        0: begin
            if (|sig)
            begin
                // Call cref_wait() begin
                res_next = cvrr_a_next[2];
                rec_arr_elem_func_param_cref2_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:726:9;
                // Call cref_wait() end
            end
            rec_arr_elem_func_param_cref2_PROC_STATE_next = 0; return;    // test_array_cthread.cpp:743:13;
        end
        1: begin
            // Call cref_wait() begin
            res_next = res_next + cvrr_b_next[2];
            TMP_0 = res_next;
            // Call cref_wait() end
            res = TMP_0;
            t19_next = res;
            rec_arr_elem_func_param_cref2_PROC_STATE_next = 0; return;    // test_array_cthread.cpp:743:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_cref2_ff
    if ( ~nrst ) begin
        rec_arr_elem_func_param_cref2_PROC_STATE <= 0;    // test_array_cthread.cpp:735:9;
    end
    else begin
        cvrr_a <= cvrr_a_next;
        res0 <= res_next;
        cvrr_b <= cvrr_b_next;
        t19 <= t19_next;
        rec_arr_elem_func_param_cref2_PROC_STATE <= rec_arr_elem_func_param_cref2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: rec_arr_elem_func_param_cref3 (test_array_cthread.cpp:748:5) 

// Thread-local variables
logic signed [1:0] cwrr_a[3];
logic signed [1:0] cwrr_a_next[3];
logic signed [31:0] res1;
logic signed [31:0] res_next0;
logic [3:0] cwrr_b[3];
logic [3:0] cwrr_b_next[3];
logic signed [31:0] indx0;
logic signed [31:0] indx_next;
logic signed [31:0] t20_next;
logic [1:0] rec_arr_elem_func_param_cref3_PROC_STATE;
logic [1:0] rec_arr_elem_func_param_cref3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : rec_arr_elem_func_param_cref3_comb     // test_array_cthread.cpp:748:5
    rec_arr_elem_func_param_cref3_func;
end
function void rec_arr_elem_func_param_cref3_func;
    integer TMP_0;
    cwrr_a_next = cwrr_a;
    cwrr_b_next = cwrr_b;
    indx_next = indx0;
    res_next0 = res1;
    t20_next = t20;
    rec_arr_elem_func_param_cref3_PROC_STATE_next = rec_arr_elem_func_param_cref3_PROC_STATE;
    
    case (rec_arr_elem_func_param_cref3_PROC_STATE)
        0: begin
            if (sig < 3)
            begin
                indx_next = sig;
                // Call cref_wait() begin
                res_next0 = cwrr_a_next[indx_next];
                rec_arr_elem_func_param_cref3_PROC_STATE_next = 1; return;    // test_array_cthread.cpp:726:9;
                // Call cref_wait() end
            end
            rec_arr_elem_func_param_cref3_PROC_STATE_next = 0; return;    // test_array_cthread.cpp:760:13;
        end
        1: begin
            // Call cref_wait() begin
            res_next0 = res_next0 + cwrr_b_next[indx_next];
            TMP_0 = res_next0;
            // Call cref_wait() end
            t20_next = cwrr_a_next[indx_next];
            rec_arr_elem_func_param_cref3_PROC_STATE_next = 0; return;    // test_array_cthread.cpp:760:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : rec_arr_elem_func_param_cref3_ff
    if ( ~nrst ) begin
        indx0 <= 0;
        rec_arr_elem_func_param_cref3_PROC_STATE <= 0;    // test_array_cthread.cpp:751:9;
    end
    else begin
        cwrr_a <= cwrr_a_next;
        res1 <= res_next0;
        cwrr_b <= cwrr_b_next;
        indx0 <= indx_next;
        t20 <= t20_next;
        rec_arr_elem_func_param_cref3_PROC_STATE <= rec_arr_elem_func_param_cref3_PROC_STATE_next;
    end
end

endmodule


