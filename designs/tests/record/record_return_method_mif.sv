//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.6
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: Top ()
//
module Top // "top"
(
    input logic clk
);


//------------------------------------------------------------------------------
// Child module instances

A b_mod
(
  .clk(clk)
);

endmodule



//==============================================================================
//
// Module: A (test_return_method_mif.cpp:204:5)
//
module A // "top.b_mod"
(
    input logic clk
);

// Variables generated for SystemC signals
logic nrst;
logic mif_nrst[2];
logic signed [31:0] mif_c[2];
logic mif_t_a[2][3][3];
logic signed [31:0] mif_t_b[2][3];
logic mif_tt_a[2][3][3];
logic signed [31:0] mif_tt_b[2][3];
logic signed [31:0] s;
logic t1_a[3];
logic signed [31:0] t1_b;
logic signed [31:0] t2;
logic t7_a[3];
logic signed [31:0] t7_b;
logic t3_a[3];
logic signed [31:0] t3_b;
logic t4_a[2][3];
logic signed [31:0] t4_b[2];
logic mif_clk[2];

// Assignments generated for C++ channel arrays
assign mif_clk[0] = clk;
assign mif_clk[1] = clk;

//------------------------------------------------------------------------------
// Method process: mif_meth (test_return_method_mif.cpp:46:5) 

always_comb 
begin : mif_meth     // test_return_method_mif.cpp:46:5
    logic r_a[3];
    integer r_b;
    logic p_a[3];
    integer p_b;
    r_a = mif_t_a[0][1]; r_b = mif_t_b[0][1];
    p_a = r_a; p_b = r_b;
    mif_t_a[0][1] = p_a; mif_t_b[0][1] = p_b;
    r_a = mif_t_a[0][1]; r_b = mif_t_b[0][1];
    r_a = p_a; r_b = p_b;
    mif_t_a[0][2] = 0; mif_t_b[0][2] = 0;
    mif_t_a[0][2] = r_a; mif_t_b[0][2] = r_b;
    mif_t_a[0][mif_c[0]] = 0; mif_t_b[0][mif_c[0]] = 0;
    mif_t_a[0][2] = mif_t_a[0][1]; mif_t_b[0][2] = mif_t_b[0][1];
    mif_t_a[0][mif_c[0]] = mif_t_a[0][1]; mif_t_b[0][mif_c[0]] = mif_t_b[0][1];
end

//------------------------------------------------------------------------------
// Clocked THREAD: mif_thrd (test_return_method_mif.cpp:62:5) 

// Thread-local variables
logic mif_n_a[2][3];
logic signed [31:0] mif_n_b[2];
logic h_a[3];
logic h_a_next[3];
logic signed [31:0] h_b;
logic signed [31:0] h_b_next;
logic mif_tt_a_next[2][3][3];
logic signed [31:0] mif_tt_b_next[2][3];
logic signed [31:0] mif_c_next[2];

// Next-state combinational logic
always_comb begin : mif_thrd_comb     // test_return_method_mif.cpp:62:5
    mif_thrd_func;
end
function void mif_thrd_func;
    logic g_a[3];
    integer g_b;
    logic j_a[3];
    integer j_b;
    h_a_next = h_a;
    h_b_next = h_b;
    mif_c_next[0] = mif_c[0];
    mif_tt_a_next[0] = mif_tt_a[0];
    mif_tt_b_next[0] = mif_tt_b[0];
    mif_tt_a_next[0][mif_c[0]] = h_a_next; mif_tt_b_next[0][mif_c[0]] = h_b_next;
    j_a = mif_tt_a[0][mif_c[0]]; j_b = mif_tt_b[0][mif_c[0]];
    mif_c_next[0] = 32'(j_a[2]);
endfunction

// Synchronous register update
always_ff @(posedge mif_clk[0] or negedge mif_nrst[0]) 
begin : mif_thrd_ff
    if ( ~mif_nrst[0] ) begin
        logic g_a[3];
        integer g_b;
        g_a = mif_n_a[0]; g_b = mif_n_b[0];
        h_a <= g_a; h_b <= g_b;
    end
    else begin
        h_a <= h_a_next;
        h_b <= h_b_next;
        mif_tt_a[0] <= mif_tt_a_next[0];
        mif_tt_b[0] <= mif_tt_b_next[0];
        mif_c[0] <= mif_c_next[0];
    end
end

//------------------------------------------------------------------------------
// Method process: mif_meth0 (test_return_method_mif.cpp:46:5) 

always_comb 
begin : mif_meth0     // test_return_method_mif.cpp:46:5
    logic r_a[3];
    integer r_b;
    logic p_a[3];
    integer p_b;
    r_a = mif_t_a[1][1]; r_b = mif_t_b[1][1];
    p_a = r_a; p_b = r_b;
    mif_t_a[1][1] = p_a; mif_t_b[1][1] = p_b;
    r_a = mif_t_a[1][1]; r_b = mif_t_b[1][1];
    r_a = p_a; r_b = p_b;
    mif_t_a[1][2] = 0; mif_t_b[1][2] = 0;
    mif_t_a[1][2] = r_a; mif_t_b[1][2] = r_b;
    mif_t_a[1][mif_c[1]] = 0; mif_t_b[1][mif_c[1]] = 0;
    mif_t_a[1][2] = mif_t_a[1][1]; mif_t_b[1][2] = mif_t_b[1][1];
    mif_t_a[1][mif_c[1]] = mif_t_a[1][1]; mif_t_b[1][mif_c[1]] = mif_t_b[1][1];
end

//------------------------------------------------------------------------------
// Clocked THREAD: mif_thrd0 (test_return_method_mif.cpp:62:5) 

// Thread-local variables
logic h_a0[3];
logic h_a_next0[3];
logic signed [31:0] h_b0;
logic signed [31:0] h_b_next0;

// Next-state combinational logic
always_comb begin : mif_thrd0_comb     // test_return_method_mif.cpp:62:5
    mif_thrd0_func;
end
function void mif_thrd0_func;
    logic g_a[3];
    integer g_b;
    logic j_a[3];
    integer j_b;
    h_a_next0 = h_a0;
    h_b_next0 = h_b0;
    mif_c_next[1] = mif_c[1];
    mif_tt_a_next[1] = mif_tt_a[1];
    mif_tt_b_next[1] = mif_tt_b[1];
    mif_tt_a_next[1][mif_c[1]] = h_a_next0; mif_tt_b_next[1][mif_c[1]] = h_b_next0;
    j_a = mif_tt_a[1][mif_c[1]]; j_b = mif_tt_b[1][mif_c[1]];
    mif_c_next[1] = 32'(j_a[2]);
endfunction

// Synchronous register update
always_ff @(posedge mif_clk[1] or negedge mif_nrst[1]) 
begin : mif_thrd0_ff
    if ( ~mif_nrst[1] ) begin
        logic g_a[3];
        integer g_b;
        g_a = mif_n_a[1]; g_b = mif_n_b[1];
        h_a0 <= g_a; h_b0 <= g_b;
    end
    else begin
        h_a0 <= h_a_next0;
        h_b0 <= h_b_next0;
        mif_tt_a[1] <= mif_tt_a_next[1];
        mif_tt_b[1] <= mif_tt_b_next[1];
        mif_c[1] <= mif_c_next[1];
    end
end

//------------------------------------------------------------------------------
// Method process: sig_ref_meth1 (test_return_method_mif.cpp:135:5) 

// Process-local variables
logic mif_m_a[2][3];
logic signed [31:0] mif_m_b[2];

always_comb 
begin : sig_ref_meth1     // test_return_method_mif.cpp:135:5
    logic l_a[3];
    integer l_b;
    logic r_a[3];
    integer r_b;
    logic TMP_2_a[3];
    integer TMP_2_b;
    logic TMP_3_a[3];
    integer TMP_3_b;
    logic TMP_4_a[3];
    integer TMP_4_b;
    logic TMP_5_a[3];
    integer TMP_5_b;
    l_a = mif_t_a[s - 1][s + 1]; l_b = mif_t_b[s - 1][s + 1];
    mif_t_a[s - 1][s + 1] = 0; mif_t_b[s - 1][s + 1] = 0;
    mif_t_a[s - 1][s + 1] = l_a; mif_t_b[s - 1][s + 1] = l_b;
    mif_t_a[s - 1][s + 1] = 0; mif_t_b[s - 1][s + 1] = 0;
    // Call read_val() begin
    r_a = mif_t_a[0][1]; r_b = mif_t_b[0][1];
    r_a = mif_m_a[0]; r_b = mif_m_b[0];
    TMP_2_a = r_a; TMP_2_b = r_b;
    // Call read_val() end
    l_a = TMP_2_a; l_b = TMP_2_b;
    // Call read_val2() begin
    TMP_3_a = mif_t_a[1][1]; TMP_3_b = mif_t_b[1][1];
    // Call read_val2() end
    l_a = TMP_3_a; l_b = TMP_3_b;
    // Call read_val() begin
    r_a = mif_t_a[s][1]; r_b = mif_t_b[s][1];
    r_a = mif_m_a[s]; r_b = mif_m_b[s];
    TMP_4_a = r_a; TMP_4_b = r_b;
    // Call read_val() end
    l_a = TMP_4_a; l_b = TMP_4_b;
    // Call read_val2() begin
    TMP_5_a = mif_t_a[s][1]; TMP_5_b = mif_t_b[s][1];
    // Call read_val2() end
    l_a = TMP_5_a; l_b = TMP_5_b;
    t1_a = l_a; t1_b = l_b;
end

//------------------------------------------------------------------------------
// Method process: sig_ref_meth2 (test_return_method_mif.cpp:156:5) 

// Process-local variables
logic signed [31:0] recArr_b[2];

always_comb 
begin : sig_ref_meth2     // test_return_method_mif.cpp:156:5
    integer i;
    i = recArr_b[0];
    t2 = i;
end

//------------------------------------------------------------------------------
// Method process: sig_ref_meth3 (test_return_method_mif.cpp:164:5) 

// Process-local variables
logic signed [31:0] mif_mmm_b[2];
logic mif_mmm_a[2][3];

always_comb 
begin : sig_ref_meth3     // test_return_method_mif.cpp:164:5
    integer i;
    logic p_a[3];
    integer p_b;
    i = mif_mmm_b[s];
    t2 = i;
    p_a = mif_mmm_a; p_b = mif_mmm_b;
    t7_a = p_a; t7_b = p_b;
end

//------------------------------------------------------------------------------
// Clocked THREAD: sig_ref_thrd (test_return_method_mif.cpp:177:5) 

// Thread-local variables
logic p_a0[3];
logic p_a_next[3];
logic signed [31:0] p_b0;
logic signed [31:0] p_b_next;
logic r_a0[3];
logic r_a_next[3];
logic t3_a_next[3];
logic signed [31:0] t3_b_next;
logic t4_a_next[2][3];
logic signed [31:0] t4_b_next[2];
logic mif_mm_a[2][3];
logic signed [31:0] mif_mm_b[2];
logic sig_ref_thrd_PROC_STATE;
logic sig_ref_thrd_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : sig_ref_thrd_comb     // test_return_method_mif.cpp:177:5
    sig_ref_thrd_func;
end
function void sig_ref_thrd_func;
    logic q_a[3];
    integer q_b;
    logic r_a[3];
    integer r_b;
    logic TMP_0_a[3];
    integer TMP_0_b;
    logic TMP_1_a[3];
    integer TMP_1_b;
    integer r_b_1;
    logic TMP_2_a[3];
    integer TMP_2_b;
    logic TMP_3_a[3];
    integer TMP_3_b;
    logic TMP_4_a[3];
    integer TMP_4_b;
    integer TMP_5;
    logic TMP_6_a[3];
    integer TMP_6_b;
    logic TMP_7_a[3];
    integer TMP_7_b;
    logic TMP_8_a[3];
    integer TMP_8_b;
    integer TMP_9;
    p_a_next = p_a0;
    p_b_next = p_b0;
    r_a_next = r_a0;
    t3_a_next = t3_a;
    t3_b_next = t3_b;
    t4_a_next = t4_a;
    t4_b_next = t4_b;
    sig_ref_thrd_PROC_STATE_next = sig_ref_thrd_PROC_STATE;
    
    case (sig_ref_thrd_PROC_STATE)
        0: begin
            r_a_next = p_a_next; r_b_1 = p_b_next;
            t3_a_next = r_a_next; t3_b_next = r_b_1;
            p_a_next = t4_a[r_a_next[s]]; p_b_next = t4_b[r_a_next[s]];
            // Call read_val_() begin
            mif_mm_a[s] = mif_t_a[s][1]; mif_mm_b[s] = mif_t_b[s][1];
            r_a = mif_mm_a[s]; r_b = mif_mm_b[s];
            mif_mm_a[s] = r_a; mif_mm_b[s] = r_b;
            TMP_2_a = r_a; TMP_2_b = r_b;
            // Call read_val_() end
            p_a_next = TMP_2_a; p_b_next = TMP_2_b;
            // Call read_val2() begin
            TMP_3_a = mif_t_a[s][1]; TMP_3_b = mif_t_b[s][1];
            // Call read_val2() end
            p_a_next = TMP_3_a; p_b_next = TMP_3_b;
            // Call read_val2() begin
            TMP_4_a = mif_t_a[0][1]; TMP_4_b = mif_t_b[0][1];
            // Call read_val2() end
            q_a = TMP_4_a; q_b = TMP_4_b;
            // Call read_int() begin
            TMP_5 = mif_c[0];
            // Call read_int() end
            sig_ref_thrd_PROC_STATE_next = 1; return;    // test_return_method_mif.cpp:193:13;
        end
        1: begin
            t4_a_next[0] = p_a_next; t4_b_next[0] = p_b_next;
            r_a_next = p_a_next; r_b_1 = p_b_next;
            t3_a_next = r_a_next; t3_b_next = r_b_1;
            p_a_next = t4_a[r_a_next[s]]; p_b_next = t4_b[r_a_next[s]];
            // Call read_val_() begin
            mif_mm_a[s] = mif_t_a[s][1]; mif_mm_b[s] = mif_t_b[s][1];
            r_a = mif_mm_a[s]; r_b = mif_mm_b[s];
            mif_mm_a[s] = r_a; mif_mm_b[s] = r_b;
            TMP_6_a = r_a; TMP_6_b = r_b;
            // Call read_val_() end
            p_a_next = TMP_6_a; p_b_next = TMP_6_b;
            // Call read_val2() begin
            TMP_7_a = mif_t_a[s][1]; TMP_7_b = mif_t_b[s][1];
            // Call read_val2() end
            p_a_next = TMP_7_a; p_b_next = TMP_7_b;
            // Call read_val2() begin
            TMP_8_a = mif_t_a[0][1]; TMP_8_b = mif_t_b[0][1];
            // Call read_val2() end
            q_a = TMP_8_a; q_b = TMP_8_b;
            // Call read_int() begin
            TMP_9 = mif_c[0];
            // Call read_int() end
            sig_ref_thrd_PROC_STATE_next = 1; return;    // test_return_method_mif.cpp:193:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge nrst) 
begin : sig_ref_thrd_ff
    if ( ~nrst ) begin
        logic q_a[3];
        integer q_b;
        logic r_a[3];
        integer r_b;
        logic TMP_0_a[3];
        integer TMP_0_b;
        logic TMP_1_a[3];
        integer TMP_1_b;
        logic mif_mm_a[3];
        integer mif_mm_b;
        p_a0 <= q_a; p_b0 <= q_b;
        // Call read_val_() begin
        mif_mm_a[0] = mif_t_a[0][1]; mif_mm_b[0] = mif_t_b[0][1];
        r_a = mif_mm_a[0]; r_b = mif_mm_b[0];
        mif_mm_a[0] = r_a; mif_mm_b[0] = r_b;
        TMP_0_a = r_a; TMP_0_b = r_b;
        // Call read_val_() end
        p_a0 <= TMP_0_a; p_b0 <= TMP_0_b;
        // Call read_val2() begin
        TMP_1_a = mif_t_a[1][1]; TMP_1_b = mif_t_b[1][1];
        // Call read_val2() end
        p_a0 <= TMP_1_a; p_b0 <= TMP_1_b;
        sig_ref_thrd_PROC_STATE <= 0;    // test_return_method_mif.cpp:183:9;
    end
    else begin
        p_a0 <= p_a_next;
        p_b0 <= p_b_next;
        r_a0 <= r_a_next;
        t3_a <= t3_a_next;
        t3_b <= t3_b_next;
        t4_a <= t4_a_next;
        t4_b <= t4_b_next;
        sig_ref_thrd_PROC_STATE <= sig_ref_thrd_PROC_STATE_next;
    end
end

endmodule


