//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.5.15
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: top ()
//
module top // "top_inst"
(
    input logic clk
);

// Variables generated for SystemC signals
logic arstn;
logic signed [31:0] out;
logic signed [31:0] in;

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread0 (test_cthread_fcall.cpp:198:5) 

// Thread-local variables
logic signed [31:0] out_next;
logic test_thread0_PROC_STATE;
logic test_thread0_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread0_comb     // test_cthread_fcall.cpp:198:5
    test_thread0_func;
end
function void test_thread0_func;
    integer k;
    out_next = out;
    test_thread0_PROC_STATE_next = test_thread0_PROC_STATE;
    
    case (test_thread0_PROC_STATE)
        0: begin
            out_next = 1;
            // Call f1() begin
            k = 0;
            test_thread0_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            out_next = 2;
            out_next = 1;
            // Call f1() begin
            k = 0;
            test_thread0_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread0_ff
    if ( ~arstn ) begin
        out <= 0;
        test_thread0_PROC_STATE <= 0;    // test_cthread_fcall.cpp:201:9;
    end
    else begin
        out <= out_next;
        test_thread0_PROC_STATE <= test_thread0_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_if1 (test_cthread_fcall.cpp:211:5) 

// Thread-local variables
logic signed [31:0] out_next0;
logic [1:0] test_thread_in_if1_PROC_STATE;
logic [1:0] test_thread_in_if1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_if1_comb     // test_cthread_fcall.cpp:211:5
    test_thread_in_if1_func;
end
function void test_thread_in_if1_func;
    integer k;
    out_next0 = out;
    test_thread_in_if1_PROC_STATE_next = test_thread_in_if1_PROC_STATE;
    
    case (test_thread_in_if1_PROC_STATE)
        0: begin
            out_next0 = 1;
            if (in > 1)
            begin
                // Call f1() begin
                k = 0;
                test_thread_in_if1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            out_next0 = 2;
            test_thread_in_if1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:224:13;
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            out_next0 = 2;
            test_thread_in_if1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:224:13;
        end
        2: begin
            out_next0 = 3;
            out_next0 = 1;
            if (in > 1)
            begin
                // Call f1() begin
                k = 0;
                test_thread_in_if1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            out_next0 = 2;
            test_thread_in_if1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:224:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_if1_ff
    if ( ~arstn ) begin
        out <= 0;
        test_thread_in_if1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:214:9;
    end
    else begin
        out <= out_next0;
        test_thread_in_if1_PROC_STATE <= test_thread_in_if1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_if2 (test_cthread_fcall.cpp:231:5) 

// Thread-local variables
logic signed [31:0] out_next1;
logic [1:0] test_thread_in_if2_PROC_STATE;
logic [1:0] test_thread_in_if2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_if2_comb     // test_cthread_fcall.cpp:231:5
    test_thread_in_if2_func;
end
function void test_thread_in_if2_func;
    integer k;
    out_next1 = out;
    test_thread_in_if2_PROC_STATE_next = test_thread_in_if2_PROC_STATE;
    
    case (test_thread_in_if2_PROC_STATE)
        0: begin
            out_next1 = 1;
            if (in > 1)
            begin
                if (in > 2)
                begin
                    // Call f1() begin
                    k = 0;
                    test_thread_in_if2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                    // Call f1() end
                end
            end
            out_next1 = 2;
            test_thread_in_if2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:246:13;
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            out_next1 = 2;
            test_thread_in_if2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:246:13;
        end
        2: begin
            out_next1 = 3;
            out_next1 = 1;
            if (in > 1)
            begin
                if (in > 2)
                begin
                    // Call f1() begin
                    k = 0;
                    test_thread_in_if2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                    // Call f1() end
                end
            end
            out_next1 = 2;
            test_thread_in_if2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:246:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_if2_ff
    if ( ~arstn ) begin
        out <= 0;
        test_thread_in_if2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:234:9;
    end
    else begin
        out <= out_next1;
        test_thread_in_if2_PROC_STATE <= test_thread_in_if2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_for1 (test_cthread_fcall.cpp:277:5) 

// Thread-local variables
logic signed [31:0] out_next2;
logic signed [31:0] i;
logic signed [31:0] i_next;
logic [1:0] test_thread_in_for1_PROC_STATE;
logic [1:0] test_thread_in_for1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_for1_comb     // test_cthread_fcall.cpp:277:5
    test_thread_in_for1_func;
end
function void test_thread_in_for1_func;
    integer k;
    i_next = i;
    out_next2 = out;
    test_thread_in_for1_PROC_STATE_next = test_thread_in_for1_PROC_STATE;
    
    case (test_thread_in_for1_PROC_STATE)
        0: begin
            out_next2 = 1;
            i_next = 0;
            // Call f1() begin
            k = 0;
            test_thread_in_for1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            i_next++;
            if (i_next < 3)
            begin
                // Call f1() begin
                k = 0;
                test_thread_in_for1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            out_next2 = 2;
            test_thread_in_for1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:290:13;
        end
        2: begin
            out_next2 = 3;
            out_next2 = 1;
            i_next = 0;
            // Call f1() begin
            k = 0;
            test_thread_in_for1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_for1_ff
    if ( ~arstn ) begin
        out <= 0;
        test_thread_in_for1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:280:9;
    end
    else begin
        out <= out_next2;
        i <= i_next;
        test_thread_in_for1_PROC_STATE <= test_thread_in_for1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_for2 (test_cthread_fcall.cpp:297:5) 

// Thread-local variables
logic signed [31:0] out_next3;
logic signed [31:0] j;
logic signed [31:0] j_next;
logic signed [31:0] i0;
logic signed [31:0] i_next0;
logic [1:0] test_thread_in_for2_PROC_STATE;
logic [1:0] test_thread_in_for2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_for2_comb     // test_cthread_fcall.cpp:297:5
    test_thread_in_for2_func;
end
function void test_thread_in_for2_func;
    integer k;
    i_next0 = i0;
    j_next = j;
    out_next3 = out;
    test_thread_in_for2_PROC_STATE_next = test_thread_in_for2_PROC_STATE;
    
    case (test_thread_in_for2_PROC_STATE)
        0: begin
            out_next3 = 1;
            i_next0 = 0;
            j_next = 0;
            // Call f1() begin
            k = 0;
            test_thread_in_for2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            j_next++;
            if (j_next < 3)
            begin
                // Call f1() begin
                k = 0;
                test_thread_in_for2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            i_next0++;
            if (i_next0 < 3)
            begin
                j_next = 0;
                // Call f1() begin
                k = 0;
                test_thread_in_for2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            out_next3 = 2;
            test_thread_in_for2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:312:13;
        end
        2: begin
            out_next3 = 3;
            out_next3 = 1;
            i_next0 = 0;
            j_next = 0;
            // Call f1() begin
            k = 0;
            test_thread_in_for2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_for2_ff
    if ( ~arstn ) begin
        out <= 0;
        test_thread_in_for2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:300:9;
    end
    else begin
        out <= out_next3;
        j <= j_next;
        i0 <= i_next0;
        test_thread_in_for2_PROC_STATE <= test_thread_in_for2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_if3 (test_cthread_fcall.cpp:253:5) 

// Thread-local variables
logic signed [31:0] out_next4;
logic [1:0] test_thread_in_if3_PROC_STATE;
logic [1:0] test_thread_in_if3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_if3_comb     // test_cthread_fcall.cpp:253:5
    test_thread_in_if3_func;
end
function void test_thread_in_if3_func;
    integer k;
    out_next4 = out;
    test_thread_in_if3_PROC_STATE_next = test_thread_in_if3_PROC_STATE;
    
    case (test_thread_in_if3_PROC_STATE)
        0: begin
            out_next4 = 1;
            if (in > 1)
            begin
                if (in > 2)
                begin
                    out_next4 = 4;
                end
                // Call f1() begin
                k = 0;
                test_thread_in_if3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            out_next4 = 2;
            test_thread_in_if3_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:270:13;
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            out_next4 = 2;
            test_thread_in_if3_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:270:13;
        end
        2: begin
            out_next4 = 3;
            out_next4 = 1;
            if (in > 1)
            begin
                if (in > 2)
                begin
                    out_next4 = 4;
                end
                // Call f1() begin
                k = 0;
                test_thread_in_if3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            out_next4 = 2;
            test_thread_in_if3_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:270:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_if3_ff
    if ( ~arstn ) begin
        out <= 0;
        test_thread_in_if3_PROC_STATE <= 0;    // test_cthread_fcall.cpp:256:9;
    end
    else begin
        out <= out_next4;
        test_thread_in_if3_PROC_STATE <= test_thread_in_if3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_multiple1 (test_cthread_fcall.cpp:397:5) 

// Thread-local variables
logic [1:0] test_thread_multiple1_PROC_STATE;
logic [1:0] test_thread_multiple1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_multiple1_comb     // test_cthread_fcall.cpp:397:5
    test_thread_multiple1_func;
end
function void test_thread_multiple1_func;
    integer j_1;
    integer k;
    test_thread_multiple1_PROC_STATE_next = test_thread_multiple1_PROC_STATE;
    
    case (test_thread_multiple1_PROC_STATE)
        0: begin
            j_1 = 1;
            // Call f1() begin
            k = 0;
            test_thread_multiple1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            j_1 = 2;
            // Call f1() begin
            k = 0;
            test_thread_multiple1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        2: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            j_1 = 1;
            // Call f1() begin
            k = 0;
            test_thread_multiple1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_multiple1_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_multiple1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:400:9;
    end
    else begin
        test_thread_multiple1_PROC_STATE <= test_thread_multiple1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_multiple2 (test_cthread_fcall.cpp:412:5) 

// Thread-local variables
logic signed [31:0] i1;
logic signed [31:0] i_next1;
logic [1:0] test_thread_multiple2_PROC_STATE;
logic [1:0] test_thread_multiple2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_multiple2_comb     // test_cthread_fcall.cpp:412:5
    test_thread_multiple2_func;
end
function void test_thread_multiple2_func;
    integer j_1;
    integer k;
    i_next1 = i1;
    test_thread_multiple2_PROC_STATE_next = test_thread_multiple2_PROC_STATE;
    
    case (test_thread_multiple2_PROC_STATE)
        0: begin
            j_1 = 1;
            i_next1 = 1;
            // Call f2() begin
            k = i_next1;
            test_thread_multiple2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:110:9;
            // Call f2() end
        end
        1: begin
            // Call f2() begin
            k = i_next1 + 1;
            // Call f2() end
            j_1 = 2;
            i_next1 = 2;
            // Call f2() begin
            k = i_next1;
            test_thread_multiple2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:110:9;
            // Call f2() end
        end
        2: begin
            // Call f2() begin
            k = i_next1 + 1;
            // Call f2() end
            j_1 = 1;
            i_next1 = 1;
            // Call f2() begin
            k = i_next1;
            test_thread_multiple2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:110:9;
            // Call f2() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_multiple2_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_multiple2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:415:9;
    end
    else begin
        i1 <= i_next1;
        test_thread_multiple2_PROC_STATE <= test_thread_multiple2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_multiple3 (test_cthread_fcall.cpp:427:5) 

// Thread-local variables
logic signed [31:0] i2;
logic signed [31:0] i_next2;
logic [2:0] test_thread_multiple3_PROC_STATE;
logic [2:0] test_thread_multiple3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_multiple3_comb     // test_cthread_fcall.cpp:427:5
    test_thread_multiple3_func;
end
function void test_thread_multiple3_func;
    integer j_1;
    integer k;
    integer k_1;
    i_next2 = i2;
    test_thread_multiple3_PROC_STATE_next = test_thread_multiple3_PROC_STATE;
    
    case (test_thread_multiple3_PROC_STATE)
        0: begin
            j_1 = 1;
            // Call f1() begin
            k = 0;
            test_thread_multiple3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        1: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            j_1 = 2;
            i_next2 = 1;
            // Call f2() begin
            k_1 = i_next2;
            test_thread_multiple3_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:110:9;
            // Call f2() end
        end
        2: begin
            // Call f2() begin
            k_1 = i_next2 + 1;
            // Call f2() end
            if (|in)
            begin
                // Call f1() begin
                k = 0;
                test_thread_multiple3_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            // Call f1() begin
            k = 0;
            test_thread_multiple3_PROC_STATE_next = 5; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        3: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            i_next2 = 2;
            // Call f2() begin
            k_1 = i_next2;
            test_thread_multiple3_PROC_STATE_next = 4; return;    // test_cthread_fcall.cpp:110:9;
            // Call f2() end
        end
        4: begin
            // Call f2() begin
            k_1 = i_next2 + 1;
            // Call f2() end
            // Call f1() begin
            k = 0;
            test_thread_multiple3_PROC_STATE_next = 5; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
        5: begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            j_1 = 1;
            // Call f1() begin
            k = 0;
            test_thread_multiple3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_multiple3_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_multiple3_PROC_STATE <= 0;    // test_cthread_fcall.cpp:430:9;
    end
    else begin
        i2 <= i_next2;
        test_thread_multiple3_PROC_STATE <= test_thread_multiple3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_params1 (test_cthread_fcall.cpp:477:5) 

// Thread-local variables
logic signed [31:0] j0;
logic signed [31:0] j_next0;
logic signed [31:0] i3;
logic signed [31:0] i_next3;
logic [1:0] test_thread_params1_PROC_STATE;
logic [1:0] test_thread_params1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_params1_comb     // test_cthread_fcall.cpp:477:5
    test_thread_params1_func;
end
function void test_thread_params1_func;
    integer TMP_0;
    integer TMP_1;
    i_next3 = i3;
    j_next0 = j0;
    test_thread_params1_PROC_STATE_next = test_thread_params1_PROC_STATE;
    
    case (test_thread_params1_PROC_STATE)
        0: begin
            i_next3 = j_next0;
            // Call f3() begin
            if (|i_next3)
            begin
                test_thread_params1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:117:13;
            end
            TMP_0 = i_next3 + 1;
            // Call f3() end
            j_next0 = TMP_0;
            test_thread_params1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:485:13;
        end
        1: begin
            i_next3 = j_next0;
            // Call f3() begin
            if (|i_next3)
            begin
                test_thread_params1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:117:13;
            end
            TMP_1 = i_next3 + 1;
            // Call f3() end
            j_next0 = TMP_1;
            test_thread_params1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:485:13;
        end
        2: begin
            // Call f3() begin
            TMP_1 = i_next3 + 1;
            // Call f3() end
            j_next0 = TMP_1;
            test_thread_params1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:485:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_params1_ff
    if ( ~arstn ) begin
        j0 <= 0;
        test_thread_params1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:480:9;
    end
    else begin
        j0 <= j_next0;
        i3 <= i_next3;
        test_thread_params1_PROC_STATE <= test_thread_params1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_params2 (test_cthread_fcall.cpp:490:5) 

// Thread-local variables
logic signed [31:0] i4;
logic signed [31:0] i_next4;
logic signed [31:0] N;
logic signed [31:0] N_next;
logic test_thread_params2_PROC_STATE;
logic test_thread_params2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_params2_comb     // test_cthread_fcall.cpp:490:5
    test_thread_params2_func;
end
function void test_thread_params2_func;
    integer j_1;
    N_next = N;
    i_next4 = i4;
    test_thread_params2_PROC_STATE_next = test_thread_params2_PROC_STATE;
    
    case (test_thread_params2_PROC_STATE)
        0: begin
            j_1 = 1;
            N_next = 1;
            // Call f4() begin
            i_next4 = 0;
            test_thread_params2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:125:13;
            // Call f4() end
        end
        1: begin
            // Call f4() begin
            i_next4++;
            if (i_next4 < N_next)
            begin
                test_thread_params2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:125:13;
            end
            // Call f4() end
            j_1 = 2;
            j_1 = 1;
            N_next = 1;
            // Call f4() begin
            i_next4 = 0;
            test_thread_params2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:125:13;
            // Call f4() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_params2_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_params2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:493:9;
    end
    else begin
        i4 <= i_next4;
        N <= N_next;
        test_thread_params2_PROC_STATE <= test_thread_params2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_params3 (test_cthread_fcall.cpp:503:5) 

// Thread-local variables
logic signed [31:0] val;
logic signed [31:0] val_next;
logic [1:0] test_thread_params3_PROC_STATE;
logic [1:0] test_thread_params3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_params3_comb     // test_cthread_fcall.cpp:503:5
    test_thread_params3_func;
end
function void test_thread_params3_func;
    integer j_1;
    integer TMP_0;
    val_next = val;
    test_thread_params3_PROC_STATE_next = test_thread_params3_PROC_STATE;
    
    case (test_thread_params3_PROC_STATE)
        0: begin
            test_thread_params3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:509:13;
        end
        1: begin
            val_next = 1;
            // Call f6() begin
            test_thread_params3_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:155:9;
            // Call f6() end
        end
        2: begin
            // Call f6() begin
            TMP_0 = val_next - 1;
            // Call f6() end
            j_1 = TMP_0;
            test_thread_params3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:509:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_params3_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_params3_PROC_STATE <= 0;    // test_cthread_fcall.cpp:506:9;
    end
    else begin
        val <= val_next;
        test_thread_params3_PROC_STATE <= test_thread_params3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_params4 (test_cthread_fcall.cpp:515:5) 

// Thread-local variables
logic signed [31:0] j1;
logic signed [31:0] j_next1;
logic b;
logic b_next;
logic signed [31:0] out_next5;
logic signed [2:0] val0;
logic signed [2:0] val_next0;
logic [1:0] test_thread_params4_PROC_STATE;
logic [1:0] test_thread_params4_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_params4_comb     // test_cthread_fcall.cpp:515:5
    test_thread_params4_func;
end
function void test_thread_params4_func;
    logic TMP_0;
    logic TMP_2;
    b_next = b;
    j_next1 = j1;
    out_next5 = out;
    val_next0 = val0;
    test_thread_params4_PROC_STATE_next = test_thread_params4_PROC_STATE;
    
    case (test_thread_params4_PROC_STATE)
        0: begin
            val_next0 = j_next1;
            // Call f6_() begin
            test_thread_params4_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:160:9;
            // Call f6_() end
        end
        1: begin
            // Call f6_() begin
            TMP_0 = |val_next0;
            // Call f6_() end
            b_next = TMP_0;
            test_thread_params4_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:522:13;
        end
        2: begin
            out_next5 = b_next;
            val_next0 = j_next1;
            // Call f6_() begin
            test_thread_params4_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:160:9;
            // Call f6_() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_params4_ff
    if ( ~arstn ) begin
        j1 <= 0;
        test_thread_params4_PROC_STATE <= 0;    // test_cthread_fcall.cpp:518:9;
    end
    else begin
        j1 <= j_next1;
        b <= b_next;
        out <= out_next5;
        val0 <= val_next0;
        test_thread_params4_PROC_STATE <= test_thread_params4_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_params5 (test_cthread_fcall.cpp:529:5) 

// Thread-local variables
logic signed [31:0] j2;
logic signed [31:0] j_next2;
logic [2:0] x;
logic [2:0] x_next;
logic signed [31:0] out_next6;
logic signed [31:0] val2;
logic signed [31:0] val2_next;
logic [1:0] test_thread_params5_PROC_STATE;
logic [1:0] test_thread_params5_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_params5_comb     // test_cthread_fcall.cpp:529:5
    test_thread_params5_func;
end
function void test_thread_params5_func;
    logic b_1;
    integer TMP_0;
    logic val1;
    integer TMP_1;
    j_next2 = j2;
    out_next6 = out;
    val2_next = val2;
    x_next = x;
    test_thread_params5_PROC_STATE_next = test_thread_params5_PROC_STATE;
    
    case (test_thread_params5_PROC_STATE)
        0: begin
            b_1 = |in;
            x_next = 5;
            val1 = b_1; val2_next = j_next2;
            // Call f6__() begin
            if (val1)
            begin
                test_thread_params5_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:167:13;
            end else begin
                x_next = x_next + val2_next;
                TMP_0 = val2_next + 2;
            end
            // Call f6__() end
            j_next2 = TMP_0;
            test_thread_params5_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:538:13;
        end
        1: begin
            // Call f6__() begin
            TMP_0 = val2_next + 1;
            // Call f6__() end
            j_next2 = TMP_0;
            test_thread_params5_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:538:13;
        end
        2: begin
            out_next6 = x_next;
            b_1 = |in;
            x_next = 5;
            val1 = b_1; val2_next = j_next2;
            // Call f6__() begin
            if (val1)
            begin
                test_thread_params5_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:167:13;
            end else begin
                x_next = x_next + val2_next;
                TMP_1 = val2_next + 2;
            end
            // Call f6__() end
            j_next2 = TMP_1;
            test_thread_params5_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:538:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_params5_ff
    if ( ~arstn ) begin
        j2 <= 1;
        test_thread_params5_PROC_STATE <= 0;    // test_cthread_fcall.cpp:532:9;
    end
    else begin
        j2 <= j_next2;
        x <= x_next;
        out <= out_next6;
        val2 <= val2_next;
        test_thread_params5_PROC_STATE <= test_thread_params5_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_multiple_wait1 (test_cthread_fcall.cpp:547:5) 

// Thread-local variables
logic [1:0] test_thread_multiple_wait1_PROC_STATE;
logic [1:0] test_thread_multiple_wait1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_multiple_wait1_comb     // test_cthread_fcall.cpp:547:5
    test_thread_multiple_wait1_func;
end
function void test_thread_multiple_wait1_func;
    integer j_1;
    integer k;
    test_thread_multiple_wait1_PROC_STATE_next = test_thread_multiple_wait1_PROC_STATE;
    
    case (test_thread_multiple_wait1_PROC_STATE)
        0: begin
            j_1 = 1;
            // Call f5() begin
            k = 0;
            test_thread_multiple_wait1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:133:9;
            // Call f5() end
        end
        1: begin
            // Call f5() begin
            k = 1;
            test_thread_multiple_wait1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:136:9;
            // Call f5() end
        end
        2: begin
            // Call f5() begin
            k = 2;
            // Call f5() end
            j_1 = 2;
            j_1 = 1;
            // Call f5() begin
            k = 0;
            test_thread_multiple_wait1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:133:9;
            // Call f5() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_multiple_wait1_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_multiple_wait1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:550:9;
    end
    else begin
        test_thread_multiple_wait1_PROC_STATE <= test_thread_multiple_wait1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_multiple_wait2 (test_cthread_fcall.cpp:560:5) 

// Thread-local variables
logic [1:0] test_thread_multiple_wait2_PROC_STATE;
logic [1:0] test_thread_multiple_wait2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_multiple_wait2_comb     // test_cthread_fcall.cpp:560:5
    test_thread_multiple_wait2_func;
end
function void test_thread_multiple_wait2_func;
    integer j_1;
    integer k;
    test_thread_multiple_wait2_PROC_STATE_next = test_thread_multiple_wait2_PROC_STATE;
    
    case (test_thread_multiple_wait2_PROC_STATE)
        0: begin
            j_1 = 1;
            // Call f5_() begin
            k = 0;
            test_thread_multiple_wait2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:144:9;
            // Call f5_() end
        end
        1: begin
            // Call f5_() begin
            if (|in)
            begin
                k = 1;
                test_thread_multiple_wait2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:148:13;
            end
            k = 2;
            // Call f5_() end
            j_1 = 2;
            j_1 = 1;
            // Call f5_() begin
            k = 0;
            test_thread_multiple_wait2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:144:9;
            // Call f5_() end
        end
        2: begin
            // Call f5_() begin
            k = 2;
            // Call f5_() end
            j_1 = 2;
            j_1 = 1;
            // Call f5_() begin
            k = 0;
            test_thread_multiple_wait2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:144:9;
            // Call f5_() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_multiple_wait2_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_multiple_wait2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:563:9;
    end
    else begin
        test_thread_multiple_wait2_PROC_STATE <= test_thread_multiple_wait2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_inside_call1 (test_cthread_fcall.cpp:449:5) 

// Thread-local variables
logic test_thread_inside_call1_PROC_STATE;
logic test_thread_inside_call1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_inside_call1_comb     // test_cthread_fcall.cpp:449:5
    test_thread_inside_call1_func;
end
function void test_thread_inside_call1_func;
    integer j_1;
    integer l;
    integer k;
    test_thread_inside_call1_PROC_STATE_next = test_thread_inside_call1_PROC_STATE;
    
    case (test_thread_inside_call1_PROC_STATE)
        0: begin
            j_1 = 1;
            // Call f7() begin
            l = 0;
            // Call f1() begin
            k = 0;
            test_thread_inside_call1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
            // Call f7() end
        end
        1: begin
            // Call f7() begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            l = 1;
            // Call f7() end
            j_1 = 2;
            j_1 = 1;
            // Call f7() begin
            l = 0;
            // Call f1() begin
            k = 0;
            test_thread_inside_call1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
            // Call f1() end
            // Call f7() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_inside_call1_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_inside_call1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:452:9;
    end
    else begin
        test_thread_inside_call1_PROC_STATE <= test_thread_inside_call1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_inside_call2 (test_cthread_fcall.cpp:462:5) 

// Thread-local variables
logic [1:0] test_thread_inside_call2_PROC_STATE;
logic [1:0] test_thread_inside_call2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_inside_call2_comb     // test_cthread_fcall.cpp:462:5
    test_thread_inside_call2_func;
end
function void test_thread_inside_call2_func;
    integer j_1;
    integer val_1;
    integer l;
    integer k;
    test_thread_inside_call2_PROC_STATE_next = test_thread_inside_call2_PROC_STATE;
    
    case (test_thread_inside_call2_PROC_STATE)
        0: begin
            j_1 = 1;
            val_1 = j_1;
            // Call f7_() begin
            l = 0;
            if (1)
            begin
                // Call f1() begin
                k = 0;
                test_thread_inside_call2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            // Call f7_() end
        end
        1: begin
            // Call f7_() begin
            // Call f1() begin
            k = 1;
            // Call f1() end
            l = 1;
            test_thread_inside_call2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:188:9;
            // Call f7_() end
        end
        2: begin
            // Call f7_() begin
            // Call f7_() end
            j_1 = 2;
            j_1 = 1;
            val_1 = j_1;
            // Call f7_() begin
            l = 0;
            if (1)
            begin
                // Call f1() begin
                k = 0;
                test_thread_inside_call2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:104:9;
                // Call f1() end
            end
            // Call f7_() end
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_inside_call2_ff
    if ( ~arstn ) begin
        integer j_1;
        j_1 = 0;
        test_thread_inside_call2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:465:9;
    end
    else begin
        test_thread_inside_call2_PROC_STATE <= test_thread_inside_call2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_in_while1 (test_cthread_fcall.cpp:319:5) 

// Thread-local variables
logic signed [31:0] i5;
logic signed [31:0] i_next5;
logic signed [31:0] N0;
logic signed [31:0] N_next0;
logic signed [31:0] j3;
logic signed [31:0] j_next3;
logic [1:0] test_thread_in_while1_PROC_STATE;
logic [1:0] test_thread_in_while1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_in_while1_comb     // test_cthread_fcall.cpp:319:5
    test_thread_in_while1_func;
end
function void test_thread_in_while1_func;
    N_next0 = N0;
    i_next5 = i5;
    j_next3 = j3;
    test_thread_in_while1_PROC_STATE_next = test_thread_in_while1_PROC_STATE;
    
    case (test_thread_in_while1_PROC_STATE)
        0: begin
            j_next3 = 0;
            N_next0 = j_next3;
            // Call f4() begin
            i_next5 = 0;
            if (i_next5 < N_next0)
            begin
                test_thread_in_while1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:125:13;
            end
            // Call f4() end
            test_thread_in_while1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:328:17;
        end
        1: begin
            j_next3++;
            if (j_next3 < 3)
            begin
                N_next0 = j_next3;
                // Call f4() begin
                i_next5 = 0;
                if (i_next5 < N_next0)
                begin
                    test_thread_in_while1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:125:13;
                end
                // Call f4() end
                test_thread_in_while1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:328:17;
            end
            test_thread_in_while1_PROC_STATE_next = 0; return;    // test_cthread_fcall.cpp:332:13;
        end
        2: begin
            // Call f4() begin
            i_next5++;
            if (i_next5 < N_next0)
            begin
                test_thread_in_while1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:125:13;
            end
            // Call f4() end
            test_thread_in_while1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:328:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_in_while1_ff
    if ( ~arstn ) begin
        test_thread_in_while1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:321:9;
    end
    else begin
        i5 <= i_next5;
        N0 <= N_next0;
        j3 <= j_next3;
        test_thread_in_while1_PROC_STATE <= test_thread_in_while1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_with_break1 (test_cthread_fcall.cpp:336:5) 

// Thread-local variables
logic signed [31:0] j4;
logic signed [31:0] j_next4;
logic [1:0] test_thread_with_break1_PROC_STATE;
logic [1:0] test_thread_with_break1_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_with_break1_comb     // test_cthread_fcall.cpp:336:5
    test_thread_with_break1_func;
end
function void test_thread_with_break1_func;
    integer k;
    j_next4 = j4;
    test_thread_with_break1_PROC_STATE_next = test_thread_with_break1_PROC_STATE;
    
    case (test_thread_with_break1_PROC_STATE)
        0: begin
            j_next4 = 0;
            if (|in)
            begin
                // Call f5() begin
                k = 0;
                test_thread_with_break1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:133:9;
                // Call f5() end
            end
            test_thread_with_break1_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:349:17;
        end
        1: begin
            // Call f5() begin
            k = 1;
            test_thread_with_break1_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:136:9;
            // Call f5() end
        end
        2: begin
            // Call f5() begin
            k = 2;
            // Call f5() end
            // break begin
            j_next4 = 0;
            if (|in)
            begin
                // Call f5() begin
                k = 0;
                test_thread_with_break1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:133:9;
                // Call f5() end
            end
            test_thread_with_break1_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:349:17;
            // break end
        end
        3: begin
            j_next4++;
            if (j_next4 < 3)
            begin
                if (|in)
                begin
                    // Call f5() begin
                    k = 0;
                    test_thread_with_break1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:133:9;
                    // Call f5() end
                end
                test_thread_with_break1_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:349:17;
            end
            j_next4 = 0;
            if (|in)
            begin
                // Call f5() begin
                k = 0;
                test_thread_with_break1_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:133:9;
                // Call f5() end
            end
            test_thread_with_break1_PROC_STATE_next = 3; return;    // test_cthread_fcall.cpp:349:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_with_break1_ff
    if ( ~arstn ) begin
        test_thread_with_break1_PROC_STATE <= 0;    // test_cthread_fcall.cpp:338:9;
    end
    else begin
        j4 <= j_next4;
        test_thread_with_break1_PROC_STATE <= test_thread_with_break1_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_with_break2 (test_cthread_fcall.cpp:355:5) 

// Thread-local variables
logic signed [31:0] j5;
logic signed [31:0] j_next5;
logic signed [31:0] i6;
logic signed [31:0] i_next6;
logic [1:0] test_thread_with_break2_PROC_STATE;
logic [1:0] test_thread_with_break2_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_with_break2_comb     // test_cthread_fcall.cpp:355:5
    test_thread_with_break2_func;
end
function void test_thread_with_break2_func;
    integer TMP_0;
    i_next6 = i6;
    j_next5 = j5;
    test_thread_with_break2_PROC_STATE_next = test_thread_with_break2_PROC_STATE;
    
    case (test_thread_with_break2_PROC_STATE)
        0: begin
            j_next5 = 0;
            test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:363:17;
        end
        1: begin
            if (|in)
            begin
                // break begin
                j_next5 = 0;
                test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:363:17;
                // break end
            end
            i_next6 = j_next5;
            // Call f3() begin
            if (|i_next6)
            begin
                test_thread_with_break2_PROC_STATE_next = 2; return;    // test_cthread_fcall.cpp:117:13;
            end
            TMP_0 = i_next6 + 1;
            // Call f3() end
            j_next5++;
            if (j_next5 < 3)
            begin
                test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:363:17;
            end
            j_next5 = 0;
            test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:363:17;
        end
        2: begin
            // Call f3() begin
            TMP_0 = i_next6 + 1;
            // Call f3() end
            j_next5++;
            if (j_next5 < 3)
            begin
                test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:363:17;
            end
            j_next5 = 0;
            test_thread_with_break2_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:363:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_with_break2_ff
    if ( ~arstn ) begin
        test_thread_with_break2_PROC_STATE <= 0;    // test_cthread_fcall.cpp:357:9;
    end
    else begin
        j5 <= j_next5;
        i6 <= i_next6;
        test_thread_with_break2_PROC_STATE <= test_thread_with_break2_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_with_break3 (test_cthread_fcall.cpp:376:5) 

// Thread-local variables
logic signed [31:0] j6;
logic signed [31:0] j_next6;
logic test_thread_with_break3_PROC_STATE;
logic test_thread_with_break3_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_with_break3_comb     // test_cthread_fcall.cpp:376:5
    test_thread_with_break3_func;
end
function void test_thread_with_break3_func;
    j_next6 = j6;
    test_thread_with_break3_PROC_STATE_next = test_thread_with_break3_PROC_STATE;
    
    case (test_thread_with_break3_PROC_STATE)
        0: begin
            j_next6 = 0;
            test_thread_with_break3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:384:17;
        end
        1: begin
            if (|in)
            begin
                // break begin
                j_next6 = 0;
                test_thread_with_break3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:384:17;
                // break end
            end
            j_next6++;
            if (j_next6 < 3)
            begin
                test_thread_with_break3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:384:17;
            end
            j_next6 = 0;
            test_thread_with_break3_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:384:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_with_break3_ff
    if ( ~arstn ) begin
        test_thread_with_break3_PROC_STATE <= 0;    // test_cthread_fcall.cpp:378:9;
    end
    else begin
        j6 <= j_next6;
        test_thread_with_break3_PROC_STATE <= test_thread_with_break3_PROC_STATE_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: test_thread_reg_arg (test_cthread_fcall.cpp:599:5) 

// Thread-local variables
logic signed [31:0] i7;
logic signed [31:0] i_next7;
logic test_thread_reg_arg_PROC_STATE;
logic test_thread_reg_arg_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : test_thread_reg_arg_comb     // test_cthread_fcall.cpp:599:5
    test_thread_reg_arg_func;
end
function void test_thread_reg_arg_func;
    integer TMP_0;
    integer val_1;
    integer TMP_1;
    i_next7 = i7;
    test_thread_reg_arg_PROC_STATE_next = test_thread_reg_arg_PROC_STATE;
    
    case (test_thread_reg_arg_PROC_STATE)
        0: begin
            val_1 = i_next7;
            // Call f0() begin
            TMP_0 = val_1 - 1;
            // Call f0() end
            test_thread_reg_arg_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:605:13;
        end
        1: begin
            i_next7 = i_next7 + 1;
            val_1 = i_next7;
            // Call f0() begin
            TMP_1 = val_1 - 1;
            // Call f0() end
            test_thread_reg_arg_PROC_STATE_next = 1; return;    // test_cthread_fcall.cpp:605:13;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge clk or negedge arstn) 
begin : test_thread_reg_arg_ff
    if ( ~arstn ) begin
        i7 <= 0;
        test_thread_reg_arg_PROC_STATE <= 0;    // test_cthread_fcall.cpp:602:9;
    end
    else begin
        i7 <= i_next7;
        test_thread_reg_arg_PROC_STATE <= test_thread_reg_arg_PROC_STATE_next;
    end
end

endmodule


